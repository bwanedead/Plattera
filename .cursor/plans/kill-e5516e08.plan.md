<!-- e5516e08-c330-455d-8127-e5238b5d42e0 ecf8935f-3d73-49b7-b08a-9a93f0dc67b2 -->
# Dossier Prewarm, Non-Breaking UI Hydration, and Shutdown Log Delay

## Objectives

- Pre-warm heavy dossier I/O at program launch so the first open is responsive.
- Use a read-only, in-memory preload cache for initial paint only; never affect edits/saves.
- Keep existing dossier manager features and persistence behavior intact.
- Improve UX: show connecting/loading instead of a red failure banner while empty.
- Surface backend shutdown logs by waiting 250ms after cleanup on X-close.

## Changes (targeted, non-breaking)

### 1) Tauri: backend prewarm (after launch) + log flush delay

- File: `frontend/src-tauri/src/lib.rs`
- After starting backend, spawn a background thread that:
- Waits for backend readiness by polling `GET http://127.0.0.1:8000/api/health` with short timeouts and backoff (e.g., 500ms → 1s → 1.5s → 2.5s). Only proceed on first success, otherwise abort silently.
- After readiness, delay an extra 800–1200ms to let other startup tasks settle.
- Then call `GET http://127.0.0.1:8000/api/dossier-management/list?limit=50&offset=0` once to warm disk/service (ignore errors).
- In the CloseRequested handler, after `cleanup_via_http(600)` add:
- `std::thread::sleep(std::time::Duration::from_millis(250));`

### 2) Frontend: read-only preload utility

- New file: `frontend/src/services/dossier/dossierPreload.ts`
- Export `startDossierPreload()` that:
- Tries a few `/api/health` probes with short timeouts
- Then fetches `dossierApi.getDossiers({ limit: 50, offset: 0 })`
- Stores result in a module-level variable `cached: Dossier[] | null`
- Export `getCachedDossiers()` to read the cached list (no writes; no persistence)
- Never used by any save/edit path

### 3) Kick off preload on app mount

- File: `frontend/pages/_app.tsx`
- `useEffect(() => { startDossierPreload(); }, [])`
- Fire-and-forget; no UI coupling

### 4) Hydrate DossierManager from preload (read-only, first paint only)

- File: `frontend/src/hooks/useDossierManager.ts`
- On mount, read `getCachedDossiers()` and if present, dispatch `UPDATE_DOSSIERS` immediately before doing normal `loadDossiers()`.
- Do not alter any CRUD flows; all edits/saves still go through API.
- Optional: clear internal preload (set to null) on `dossiers:refresh` to avoid stale reuse (not strictly necessary since we only consume once).

### 5) UX: keep spinner while empty; show error only with content

- File: `frontend/src/components/dossier/DossierList.tsx`
- If `error && dossiers.length > 0`: show the soft error banner.
- If `dossiers.length === 0` and (`isLoading || error`): show the loading spinner with text `Connecting to backend…` when error, otherwise `Loading dossiers…`.
- Only show the empty state if no error and not loading.
- File: `frontend/src/components/dossier/DossierManager.tsx`
- Gate the bottom "Error loading dossiers" block behind `state.dossiers.length > 0`.

## Non-Breaking Guarantees

- The preload cache is read-only, in-memory, and only used to seed the first paint.
- All mutations (create/update/delete, saves, reconciliations) still hit the API and disk; the cache is never written to from user actions.
- Normal `loadDossiers()` still runs; prewarm only improves perceived responsiveness.

## Validation

- Launch app → prewarm hits backend; opening Dossier Manager shows content near-instantly (from cache), then refreshes live data.
- Edits/saves reflect on disk; no stale cache effect.
- Closing via X shows backend shutdown logs thanks to the 250ms delay.
- Network failures during prewarm do not affect functionality; the app behaves as before (just without prewarm benefits).

### To-dos

- [ ] Add backend warmup thread and 250ms log delay in src-tauri/lib.rs
- [ ] Create read-only preload utility dossierPreload.ts
- [ ] Kick off startDossierPreload in pages/_app.tsx
- [ ] Hydrate useDossierManager from preload before normal load
- [ ] Update DossierList and DossierManager to keep spinner while empty
- [ ] Manual test warm-start, edits, retries, and shutdown logs